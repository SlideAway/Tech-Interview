# 로드맵 이름

## 스프링 핵심 원리 - 기본편  

### ❔[1. 중복되는 빈이 발생하면 스프링 컨테이너는 어떻게 반응하는가?](#❕1)
### ❔[2. 스프링 빈 스코프에는 어떤 종류가 있는가? ](#❕2)

---
## 모범답안

### ❕[1. 중복되는 빈이 발생하면 스프링 컨테이너는 어떻게 반응하는가?](#❔1)

<details> <summary>1. 모범답안</summary> <div markdown="1">  


  ```
  중복된 빈 모두 자동으로 등록된 빈이라면 빈 충돌 오류가 발생한다. 
  그러나, 중복된 빈 중 수동으로 등록된 빈이 있다면 수동 빈이 자동으로 등록된 빈을 오버라이딩한다. 
  ```

  ##### 해설
    자동으로 등록된 빈끼리 중복 시 NoUniqueBeanDefinitionException 이 발생한다. 
    수동으로 등록된 빈과 자동으로 등록된 빈이 중복 시 수동으로 등록된 빈이 자동으로 등록된 빈을 오버라이딩 하고, 경고 로그를 출력한다. 
    

</div> </details>


<details> <summary>1-1. 빈 중복을 방지하기 위해 어떤 방법이 있는가?</summary> <div markdown="1">  


  ```
  1. @Autowired 필드명 매칭 
  2. @Qualifier 로 빈 매칭 
  3. @Primary 로 메인 빈 매칭 
  ```

  ##### 해설

    @Autowired로 타입으로 매칭하고, 타입 매칭이 2개 이상일 경우 이름으로 빈을 매칭할 수 있다. 

    @Qualifier로 빈 이름 외에 추가적인 구분자를 붙여주어 빈을 주입받는 곳과, 빈을 선언하는 곳에서 구분자로 매칭 시켜준다. 이는 빈 이름을 바꿔주는것이 아니다. 

    @Primary 로 주로 사용할 빈을 설정하면 별도의 옵션 없이 빈 주입 시 자동으로 @Primary 가 붙은 빈을 주입받는다.  

</div> </details>



<details> <summary>1-2. @Primary와 @Qualifier 중 무엇이 더 우선순위가 높은가?</summary> <div markdown="1">  


  ```
  @Qualifier 가 우선권이 더 높습니다. 
  ```

  ##### 해설
    스프링은 기본적으로 자동보다는 수동이, 넓은 범위의 선택권 보다는 좁은 범위의 선택권이 우선순위가 높다. 

    @Primary는 별도의 빈 옵션을 지정하지 않아도 기본값으로 작동하는 반면, @Qualifier는 매우 상세하게 작동한다. 
    
    따라서 @Qualifier가 우선권을 더 높게 가진다. 

</div> </details>

<br>

### ❕[2. 스프링 빈 스코프에는 어떤 종류가 있는가? ](#❔2)

<details> <summary>2. 모범답안</summary> <div markdown="1">  


  ```
  기본적인 빈 스코프에는 싱글톤, 프로토타입이 있으며, 
  
  웹 스코프로는 Requst, Session, Application, WebSocket 등이 있습니다. 
  ```

  ##### 해설
    스프링 빈 스코프에는 싱글톤, 프로토타입이 있고, 별도의 설정이 없다면 싱글톤으로 작동한다. 
    
    그 밖에 스프링 웹 사용 시 Request, Session, Application, WebSocket 같은 스코프가 있고, 
    
    스프링 배치 사용 시 Job, Step 같은 스코프가 존재한다. 

    싱글톤 스코프는 스프링 컨테이너 상에서 유일하게 존재하는 빈으로, 의존관계 주입 시 똑같은 빈을 주입하게 된다. 

    프로토타입 빈은 의존관계 주입 시 새로운 빈을 생성하여 주입하므로 생성, 의존관계 주입까지만 스프링 컨테이너에서 관리하고, 

    그 이후는 주입받은 클라이언트 빈에서 관리한다.

</div> </details>


<details> <summary>2-1. 싱글톤 빈과 프로토타입 빈을 동시에 사용할 경우 어떤 문제가 발생할 수 있는가?</summary> <div markdown="1">  


  ```
  예를 들어 프로토타입 빈을 주입받는 클라이언트 빈이 싱글톤일 때 
  
  싱글톤 빈은 스프링 컨테이너 생성 시 의존관계가 이미 주입되었습니다. 
  
  해당 싱글톤 빈을 호출해도 싱글톤 빈에서는 이미 주입된 프로토타입 빈을 따로 주입받지 않으므로 
  
  프로토타입 빈을 계속 사용하게 됩니다.
  
  결국에 프로토타입 빈으로 선언된 빈은 주입 이후에는 싱글톤 빈처럼 실행되게 됩니다.   
  ```

  ##### 해설
    싱글톤 빈은 스프링 컨테이너 생성 시 의존관계가 주입되어 그 이후로는 변경되는 것이 없다. 
    
    싱글톤 빈에 프로토타입 빈 주입 시 컨테이너 생성 시점에 싱글톤 빈에 프로토타입 빈이 새로 생성되어 주입되는 것 까지는 맞다. 

    그러나 싱글톤 빈은 추가적인 주입을 받지 않으므로 초기에 주입된 프로토타입 빈을 계속 사용하게 되어, 

    결국에 프로토타입 빈이 싱글톤 빈처럼 작동하게 된다. 

</div> </details>

<details> <summary>2-2. 해결 방법은 무엇이 있으며 가장 권장하는 방법은 무엇이고, 그 이유까지 말하시오. </summary> <div markdown="1">  


  ```
  방법은 아래와 같습니다. 
  1. 스프링 컨테이너에서 의존관계 탐색하여 가져오기 
  2. ObjectProvider(ObjectFactory) 에서 의존관계 탐색하여 가져오기
  3. Provider에서 의존관계 탐색하여 가져오기 
  
  이 중 가장 권장하는 방법은 세번째 방법인 Provider에서 의존관계 탐색하여 가져오기 입니다. 
  
  그 이유는 스프링에 덜 의존적인 JSR-330 자바 표준이기 때문입니다.    
  ```

##### 해설
    1. 스프링 컨테이너에서 의존관계 탐색하여 가져오기
    2. ObjectProvider(ObjectFactory) 에서 의존관계 탐색하여 가져오기
    3. Provider에서 의존관계 탐색하여 가져오기

    스프링 컨테이너에서 의존관계 탐색하여 가져오는 방법은 스프링에 종속적인 코드가 작성되고, 
    이는 과거 EJB의 문제를 담습하는 문제가 발생할 수 있다. 
    또한, 해당 문제를 해결하는 방법은 다른 기능 필요 없이 Dependency Lookup 기능만 필요한데, 
    스프링 컨테이너를 사용하기에는 너무 많은 기능을 가지고 있어 부적절하다. 

    ObjectProvider는 스프링 컨테이너 대신 사용하여 오직 DL만 수행할 수 있는 기능을 제공한다. 
    그러나 이 방법도 스프링에 종속되는 코드가 작성되는 문제는 해결할 수 없다. 

    가장 권장되는 방법은 JSR-330 자바 표준 기능인 Provider를 사용하는 것이다.
    이 기능을 사용하면 스프링에 종속적인 코드가 발생하지 않아, 다른 프레임워크에 이식할 때도 유연하게 이식할 수 있다. 


</div> </details>

<details> <summary> 2-3. (추가)강의에서 DL 뿐만 아니라 다른 기능에서도 스프링에 덜 의존적인 방법을 더 권장하는 경향이 있다. 그 이유는 무엇이라고 생각하는가?</summary> <div markdown="1">  


  ```
  스프링 프레임워크에 덜 의존적인 코드를 짜야 추후에 다른 프레임워크로 변경 시 영향도가 적기 때문입니다. 
  ```

  ##### 해설

    스프링에 덜 의존적인 방법을 권장하는 이유는 

    스프링 프레임워크에 덜 의존적인 코드를 작성하면 POJO에 더 가까운 코드를 작성할 수 있기 때문이다. 
    
    POJO 는 Plain Old Java Object 를 의미하는데, 사전적인 정의로는 
    
    어떠한 라이브러리나 프레임워크에 종속적이지 않은 순수한 Java 객체를 의미한다.

    POJO를 지향하는 이유는 특정 규약이나 특정 환경에 종속되지 않기 위함이다.

    만약 과거 EJB처럼 특정 규약이나 환경에 종속된다면 다른 환경에서 사용 시 호환을 고려해야 하므로 

    환경 변경 시 코드 변경이 까다로워지고 비즈니스 로직과 기술적인 코드가 섞여 

    결과적으로는 독립적으로 단위테스트 하기가 힘들어진다.  

    예시를 든다면, SpringFramework의 기능 중 과거에는 많이 쓰였지만, 최근에는 Depreciated 된 기능들이 있다. 

    프레임워크를 꾸준히 버전업 하다보면 Depreciated 된 기능을 걷어내고 대체할 수 있는 기능을 적용해야 하는데, 

    이렇게 된다면 테스트 코드도 다시 짜야하고, 그 과정에서 SOLID 원칙 중 OCP를 위반할 가능성이 높다. 


</div> </details>
