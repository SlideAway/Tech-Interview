# 로드맵 이름

## 01. 스프링 웹 개발 기초

### ❔[1. 라이브러리와 프레임워크의 차이는 무엇인가?](#❕1)
### ❔[2. 스프링 부트에서는 어떻게 자동으로 컴포넌트 스캔을 할 수 있는가?](#❕2)
### ❔[3. 프로젝트 설계 시 인터페이스를 사용하는 이유는 무엇인가?](#!3)

---
## 모범답안

### ❕[1. 라이브러리와 프레임워크의 차이는 무엇인가?](#❔1)

<details> <summary>1. 모범답안</summary> <div markdown="1">  


  ```text
  프레임워크는 개발자가 작성한 코드를 호출하여 개발자의 코드를 제어할 수 있습니다. 
  반면,  라이브러리는 개발자의 코드에서 호출되어, 개발자가 라이브러리를 제어할 수 있습니다. 
  코드 흐름 제어의 주도권이 개발자에게 있느냐, 코드에 있느냐에 따라 라이브러리, 프레임워크가 나뉩니다. 
  ```

</div> </details>


<details> <summary>1-1. 스프링 프레임워크는 라이브러리인가? 프레임워크인가? 이유까지 포함하여 설명하시오</summary> <div markdown="1">  


  ```text
  스프링 프레임워크는 프레임워크입니다. 
  그 이유는 스프링 프레임워크 실행 시 개발자가 작성한 클래스를 인스턴스화 하여 Bean으로 관리하여 각 객체마다 필요한 의존성을 주입해 줍니다. 
  의존성이나 생성자는 개발자가 선언만 하지 실제 인스턴스화 하는 것과 의존성 주입에 대한 제어는 스프링 프레임워크에서 하므로 스프링 프레임워크는 프레임워크입니다.  
  ```

</div> </details>

<details> <summary>1-2. 스프링 프레임워크는 개발자의 코드를 어떻게 인스턴스화 하고 메소드를 실행하는가?</summary> <div markdown="1">
```text 
Java의 Reflection 이라는 기능으로 인스턴스화 하고, 메소드를 실행시킵니다. 
Reflection 이란, 실행중인 Java 어플리케이션에서 다른 클래스의 내부를 검사하고, 속성을 수정하고, 메소드를 동적으로 실행시키거나, 선언된 생성자를 불러와 호출하여 동적으로 객체를 만드는 등의 기능을 수행할 수 있는 Java의 기능입니다. 

단점으로는 런타임 시에 클래스를 분석하기 때문에 느리고, 프로그램의 복잡도를 늘려 유지보수 하기 힘든 코드가 발생할 수도 있습니다.
따라서 프레임워크를 만드는 등의 특별한 목적이 아니면 사용하지 않는 기능입니다.

```
</div> </details>


<br>

### ❕[2. 스프링 부트에서는 어떻게 자동으로 @Component나 @Controller 등의 어노테이션이 붙은 클래스를 빈으로 선언 할 수 있는가?](#❔2)

<details> <summary>2. 모범답안</summary> <div markdown="1">  


  ```text
  스프링 부트 프로젝트 생성 시 메인 클래스에 @SpringBootApplication 이라는 어노테이션에서 @ComponentScan 어노테이션으로 메인 클래스의 레벨 및 하위 패키지를 자동으로 스캔합니다.
  
  그 후 선언된 어노테이션에 맞는 빈으로 인스턴스화 됩니다.   
  ```

</div> </details>


<details> <summary>2-1. 그렇다면 스프링 부트 프로젝트의 메인 클래스보다 상위 패키지에 선언한 클래스를 자동으로 스캔하려면 어떻게 해야하는가?</summary> <div markdown="1">  


  ```text
  구조에 따라 다르지만, 적절한 위치에서 해당 패키지만 스캔하도록 아래처럼 어노테이션을 사용합니다.  
  ```
```java
@ComponentScan(value="com.example.*")
```
</div> </details>



<details> <summary> 2-2. @Component나 @Controller 같은 어노테이션 없이 빈으로 어떻게 선언할 수 있는가?</summary> <div markdown="1">  


  ```
  Config 파일에서 @Bean으로 선언한 메소드에 빈으로 선언할 클래스의 생성자를 아래와 같이 호출합니다. 
  ```

```java
@Configuration
public class AppConfig {
  @Bean
  public ManaualBean manualBean() {
    return new ManualBean();
  }
}
```

</div> </details>

### ❕[3. 프로젝트 설계 시 인터페이스를 사용하는 이유는 무엇인가?](#❔3)

<details> <summary>3. 모범답안</summary> <div markdown="1">

  ```text
  SOLID 원칙 중 단일 책임 원칙, 개방-폐쇄원칙, 인터페이스 분리 원칙, 의존관계 원칙을 지켜 확장성이 좋고 유지보수하기 좋은 코드를 작성하기 위해서입니다.  
  ```

</div></details>

<details> <summary> 3-1. 인터페이스를 사용하면 왜 확장성이 좋아지는가? </summary> <div markdown="1">

```text
인터페이스 사용 시 구성 설정만 변경하면 어떠한 구현체가 와도 해당 인터페이스를 사용하는 클래스에서는 변경하지 않고도 교체된 구현체를 사용할 수 있습니다. 

```
</div></details>
<details> <summary> 3-2. 인터페이스를 사용하는게 항상 옳은가? </summary> <div markdown="1">

```text
아닙니다. 인터페이스를 사용한다는 것은 추상화를 한다는 의미인데 추상화는 기본적으로 행위를 정의하고 구조를 잡는 데 비용이 많이 듭니다. 
따라서 확장 가능성이 보인다면 인터페이스를 사용하는 것이 맞지만, 확장 가능성이 당장 보이지 않는다면 굳이 인터페이스를 사용해 구현하지 않고 추후에 리팩터링을 통해 인터페이스로 구현하면 됩니다.  

```
</div></details>
